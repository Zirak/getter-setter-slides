<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Zirak | The Getter/Setter Hierarchy</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/simple.css" id="theme">

	<link rel="stylesheet" href="plugin/highlight/docco.css" id="highlight-theme">
  </head>
  <body>
	<div class="reveal">
	  <div class="slides">
        <section data-markdown>
          <script type="text/template">
          ## Overview
          1. Functions are special values
          1. [x] Getter / Setter are functions with specific signatures
          1. [x] Setter-setters (callbacks)
              1. [x] Nodebacks
              1. [ ] Convention vs. language features (`cb(err)` vs. `throw err` etc.)
          1. [x] Promises (setter-setters with signature)
              1. [?] Illustrate values flow from setter->getter
              1. [x] Alternative: Task (lazy, cancellable, unicast)
          1. [ ] Getter-getters (brief overview)
          1. Iterators (getter-getters with contract)
              1. Contract in js
              2. Generators
              3. 2c coroutine implementation in js
          1. Async iterable (iterator with async `next`)
          1. Stream
          1. Observable
          </script>
        </section>

        <section data-markdown>
        <script type="text/template">
          ## The Getter/Setter Hierarchy
        </script>
        </section>

        <section>
          <h3>whoami</h3>
          <img src="images/awesome.png" width="256" height="256" style="border: 0; float: right; box-shadow: initial;" />
          <ul>
              <li>Zirak</li>
              <li>I like JS</li>
              <li><a href="https://zirak.me">https://zirak.me</a></li>
              <p>&nbsp;</p>
              <li>Did I forget to record my screen?</li>
              <li>But enough about me</li>
          </ul>
        </section>

        <section data-markdown>
        <script type="text/template">
          ## Getter/Setter Hierarchy

          - Talk about the nature of values
          - `4`
          - Promise
          - Observable?
        </script>
        </section>

        <section>
          <pre><code class="javascript">
            const config = {
              apiPort: 4444,
            };

            // vs

            function getConfig() {
              return { apiPort: 4444 };
            }
          </code></pre>

          <ul>
            <li>Why have functions at all?
            <li>Why can't we just put use values?

            <li class="fragment">When we <em>don't care</em> how something is done
            <li class="fragment">When the value is <em>somewhere else</em>
          </ul>

          <aside class="notes">
            <p>Functions create an API. They're created because of natural process/system/etc. boundaries</p>
          </aside>
        </section>

        <section>
          <section>
            <h2>Getter</h2>
            <p>A function which returns a value</p>
            <code>() => T</code>

            <p>&nbsp;</p>

            <h2>Setter</h2>
            <p>A function which receives a value</p>
            <code>T => ()</code>
          </section>

          <section data-markdown>
            <script type="text/template">
              ## Getter examples

              - `Date.now()`
              - `require(...)`
              - `document.getElementById`
              - User input
              - Network, fs, ROM, ...
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Setter examples

              - Changing the world!
              - `console.log`
              - `readFile`, `socket.write`, ...
            </script>
          </section>

          <section data-markdown>
          <script type="text/template">
            ## Value

            ```js
            function value() {
              let x = 4;

              return {
                get() {
                  return x;
                },

                set(y) {
                  x = y;
                }
              }
            }
            ```
          </script>
          </section>
        </section>

        <section>
          <section>
            <h2>Callback pattern</h2>
            <p>Setter-of-setter</p>
          </section>

          <section data-markdown>
            <script type="text/template">
            ```javascript
            function readConfig(cb) {
              const config = { apiPort: 4444 };
              cb(config);
            }
            ```

            ```
              readConfig(cb: Config => ()) => ()
            ```

            - <!-- .element: class="fragment" --> <code>cb</code> is a setter: A function which receives a value
            - <!-- .element: class="fragment" --> <code>readConfig</code> is a setter: A function which receives a value
            - <!-- .element: class="fragment" --> ...but a setter of <em>setters</em>: A setter which receives another setter
          </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ## nodebacks
            - A setter-of-setters with a social contract
            - With the contract our example more like:

            ```javascript
            function readConfig(cb) {
              magicallyReadConfig(configPath, (err, config) => {
                if (err) {
                  cb(err);
                } else {
                  config.apiPort ||= 4444; // coming soon!
                  cb(config);
                }
              });
            }
            ```
          </script>
          </section>
        </section>

        <section>
          <section>
            <h2>Promise</h2>
            <p>Setter-of-setters with a contract</p>
          </section>
          <section data-markdown>
            <script type="text/template">
            ## Promises of a Promise
            - Not a social construct
            - A data structure

            Note:
            The contract is:
            - Either resolved/rejected
            - Never called more than once
            - Always async (zalgo)
            </script>
          </section>
          <section data-markdown="">
            <script type="text/template">
              ## Resolver

              - The function passed to `Promise` constructor
              ```javascript
              const p = new Promise(resolver);
              function resolver(resolve, reject) {
                  // ...
              }
              ```

              - Signature:
              ```
              resolver(resolve: T => (), reject: S => ()) => ()
              ```
              - <!-- .element: class="fragment" --> The resolver is a <em>setter</em> of <em>two setters</em>
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ## `then`able
  
              ```javascript
              p.then((x) => {
                console.log('such a lovely', x);
              }, (err) => {
                console.log('oh no!', err);
              });
              ```
            </script>
            </section>

          <section>
            <h2>Resolver</h2>
            <p>Contract around a setter of two setters</p>
            <code data-trim>
              resolver(T => (), S => ()) => ()
            </code>

            <h2>`then`able</h2>
            <p>Contract around a setter of two setters</p>
            <code data-tram>
              then(T => (), S => ()) => lets-ignore-this
            </code>
          </section>

        </section>

        <section>
          <section data-markdown>
          <script type="text/template">
            ## Getter-of-getters
          </script>
          </section>

          <section>
            - No catchy name like callbacks
            - Used when encapsulating local state
          </section>

          <section>
            <pre class="fade-out"><code class="javascript">              function iterate() {
                const arr = ['foo', 'bar'];
                let i = 0;

                return () => {
                  const ret = arr[i];
                  i += 1;
                  return ret;
                };
              }

              const getItems = foo();
              getItems(); // 'foo'
              getItems(); // 'bar'</code></pre>

            <pre><code>              iterate() => (
                () => string
              )</code></pre>
          </section>

          <section data-markdown>
          <script type="text/template">
            ## Iterators

            Getter-of-getters with a contract

            ```
            iterator() => {
              next() => { value: T, done: boolean }
            }
            ```
          </script>
          </section>

          <section>
            <pre><code class="javascript" data-trim>
              // Never use this function
              function iterate() {
                const arr = ['foo', 'bar'];
                let i = 0;

                return {
                  next() {
                    if (i >= arr.length) {
                      return { done: true };
                    }

                    const ret = arr[i];
                    i += 1;

                    return {
                      value: ret,
                      done: false,
                    };
                  },
                };
              }

              const rand = prng();
              rand.next(); // { value: 2563, done: false }
              rand.next(); // { value: 31856, done: false }
            </code></pre>
          </section>

          <section data-markdown>
            <script type="text/template">
              ## Generators

              Syntax sugar for creating iterators

              ```javascript
              function* prng() {
                let seed = 0xdeadcafe;
                while (true) {
                  seed *= 1700;
                  seed %= 0x7fff;
                  yield seed;
                }
              }

              const rand = prng();
              rand.next(); // { value: 2563, done: false }
              rand.next(); // { value: 31856, done: false }
              ```
            </script>
            </section>

          <section>
            <h2>Iterable</h2>
            <p>An object with a <code>Symbol.iterator</code> key,</p>
            <p>a function which returns an iterator</p>
          </section>

          <section data-markdown>
          <script type="text/template">
            ## Aside: Coroutines

            - You can send values back _into_ an iterator
            - Models a [coroutine]((http://www.dabeaz.com/coroutines/Coroutines.pdf)) / state machine

            ```javascript
            function* foo() {
              const x = yield;
              return x * 2;
            }

            const g = foo();
            g.next(); // { value: undefined, done: false }
            g.next(2); // { value: 4, done: true }
            ```
          </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ## Aside: throw / return
  
              - `gen.throw()` causes an exception
              - `gen.return()` forces an early return
            </script>
            </section>

          <section>
            <h3>Aside: Implementing coroutines</h3>

            <ul>
              <li>Coroutines model a state machine
              <li>Progress it in <code>next</code> calls
            </ul>

            <pre><code class="javascript" data-trim>
            function* fYield() {
              const x = yield;
              const y = yield x * 2;
              return y;
            }

            const fState = {
              [Symbol.iterator]() {
                let step = 0;
                let vars = {};
                return {
                  next(...args) {
                    switch (step) {
                      case 0:
                        step += 1;
                        return { value: undefined, done: false };
                      case 1:
                        step += 1;
                        vars.x = args[0];
                        return { value: vars.x * 2, done: false };
                      case 2:
                        step += 1;
                        vars.y = args[0];
                        return { value: vars.y, done: true };
                      case 3:
                        return { value: undefined, done: true };
                    }
                  }
                };
              },
            };
            </pre></code>
          </script>
          </section>
        </section>

        <section>
          <section data-markdown>
          <script type="text/template">
            ## Getter/setter hierarchy

            - Value: Setter <-> Getter
            - Async value: Resolver <-> Promise
            - Collection: Generator <-> Iterator
          </script>
          </section>

          <section data-markdown>
          <script type="text/template">
            # Properties
          </script>
          </section>

          <section>
            <h3>Lazy vs. Eager</h3>

            <pre><code class="javascript">
              const config = {
                apiPort: 4444,
              };
  
              // vs
  
              function getConfig() {
                return { apiPort: 4444 };
              }
            </code></pre>

            <ul>
              <li>Values are <em>eager</em>: Computed now</li>
              <li>Functions are <em>lazy</em>: Computed when called</li>
            </ul>

            <aside class="notes">
              Contrast to an IIFE: A function called now.
            </aside>
          </section>

          <section>
            <h3>Promises: Lazy vs. Eager</h3>

            <pre><code class="javascript">
              const p = new Promise((resolve) => {
                console.log('ketchup');
                resolve(4);
              });
              console.log('mayo');
            </code></pre>

            <ul class="fragment">
              <li>The resolver is called immediately</li>
              <li>They are computed <em>now</em></li>
              <li>Promises are deferred <em>values</em></li>
            </ul>
          </script>
          </section>

          <style>
            .reveal table.col th:first-child {
              border-right: 1px solid;
            }
            .reveal table.col tbody th, .reveal table.col tbody td {
              border-bottom: 0;
              padding: 0.6em 0.8em 0.6em 0.8em;
            }
          </style>

          <section data-markdown>
          <script type="text/template">
            <table class="col">
              <thead>
                <th>
                <th>Eager
                <th>Lazy
              </thead>
              <tr>
                <th>Spatial
                <td>Value
                <td>Function
              <tr>
                <th>Temporal
                <td>Promise
                <td class="fragment">Task
            </table>
          </script>
          </section>

          <section data-markdown>
          <script type="text/template">
            Tasks model future _actions_

            ```js
            const t = new Task((resolve, reject) => {
              console.log('inside resolver');
              resolve(4);
            });

            setTimeout(() => {
              t.then((x) => {
                console.log('such a lovely', x);
              });
            }, 4000);
            ```
          </script>
          </section>

          <section>
            <table class="col">
              <thead>
                <th>
                <th>Eager
                <th>Lazy
              </thead>
              <tr>
                <th>Singular
                <td>Value
                <td>Function
              <tr>
                <th>Plural
                <td class="fragment">Array
                <td class="fragment">Generator*
            </table>
          </section>

          <section data-markdown>
          <script type="text/template">
            ## Push / Pull

            - The getter hierarchy is _pull_
              - Consumer controls when values are received
            - The setter pyramid is _push_
              - Producer controls when values are received
          </script>
          </section>
        </section>

        <section data-markdown>
        <script type="text/template">
          <table class="col">
            <thead>
              <th>
              <th>Singular
              <th>Plural
            </thead>
            <tr>
              <th>Spatial
              <td>Value
              <td>Collection
            <tr>
              <th>Temporal
              <td>Promise
              <td class="fragment">Stream
          </table>
        </script>
        </section>

        <section data-markdown>
        <script type="text/template">
          ## Further reading

          - Kris Kowal - [General Theory of Reactivity](https://github.com/kriskowal/gtor)
          - André Staltz - [Getter / Setter Pyramid](https://staltz.com/javascript-getter-setter-pyramid.html)
          - Erik Meijer
            - [What does it mean to be Reactive?](https://www.youtube.com/watch?v=sTSQlYX5DU0)
            - [Duality and the End of Reactive](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Keynote-Duality)
          - Ben Lesh (shameless pandering) - [Observable is just a function](https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87)
        </script>
        </section>

        <section>
          <h1>Thank You
          <h3>Questions?
        </section>
	  </div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
	  // More info about initialization & config:
	  // - https://revealjs.com/initialization/
	  // - https://revealjs.com/config/
	  Reveal.initialize({
      hash: true,
      controlsTutorial: false,
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
	  });
	</script>
  </body>
</html>
